import mongoose from 'mongoose';
import Rating from "../models/ratings.js";
import Center from "../models/centers.js";
import nodemailer from "nodemailer";
import axios from "axios";

export const updateAvgRating = async (centerId) => {
  try {
    // T·∫°o ObjectId h·ª£p l·ªá t·ª´ centerId b·∫±ng c√°ch s·ª≠ d·ª•ng 'new'
    const objectId = new mongoose.Types.ObjectId(centerId);

    // T√≠nh to√°n ƒëi·ªÉm trung b√¨nh t·ª´ t·∫•t c·∫£ c√°c ƒë√°nh gi√° c·ªßa center
    const ratings = await Rating.aggregate([
      { $match: { center: objectId } }, // S·ª≠ d·ª•ng objectId thay v√¨ centerId th√¥
      { $group: { _id: "$center", avgRating: { $avg: "$stars" } } } // T√≠nh trung b√¨nh stars
    ]);

    console.log("üîç K·∫øt qu·∫£ t·ª´ aggregate:", ratings); // In ra k·∫øt qu·∫£ t·ª´ aggregate

    const newAvg = ratings.length > 0 ? ratings[0].avgRating : 0; // N·∫øu c√≥ ƒë√°nh gi√° th√¨ l·∫•y trung b√¨nh, n·∫øu kh√¥ng th√¨ g√°n 0
    console.log("üîç newAvg:", newAvg); // In ra gi√° tr·ªã c·ªßa newAvg

    // C·∫≠p nh·∫≠t avgRating v√†o Center
    await Center.findByIdAndUpdate(centerId, { avgRating: newAvg });
    console.log(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t avgRating cho Center ${centerId}: ${newAvg}`);
  } catch (error) {
    console.error("‚ùå L·ªói khi c·∫≠p nh·∫≠t avgRating:", error);
  }
};

export default updateAvgRating;

// H√†m ki·ªÉm tra email v·ªõi Hunter.io API
export const checkEmailExistsService = async (email) => {
    const apiKey = "b70f4eb3ad5581c2dafeffb3a8583b75fe275225";
    const url = `https://api.hunter.io/v2/email-verifier?email=${email}&api_key=${apiKey}`;
    try {
        const response = await axios.get(url);
        const data = response.data.data;
        if (data.status === "invalid") {
            return { success: false, message: "Email kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i!" };
        }
        if (data.disposable) {
            return { success: false, message: "Email n√†y l√† email t·∫°m th·ªùi (disposable)!" };
        }
        if (data.block) {
            return { success: false, message: "Email b·ªã ch·∫∑n ho·∫∑c thu·ªôc danh s√°ch ƒëen!" };
        }
        if (data.score < 50) {
            return { success: false, message: "Email kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng ƒë√°ng tin c·∫≠y!" };
        }
        return {
            success: true,
            message: `Email h·ª£p l·ªá! (ƒê·ªô tin c·∫≠y: ${data.score}%)`
        };
    } catch (error) {
        console.error("‚ùå L·ªói ki·ªÉm tra email:", error.response?.data || error.message);
        return { success: false, message: "L·ªói h·ªá th·ªëng khi ki·ªÉm tra email!" };
    }
};

export const sendEmailService = async (to, subject, html) => {
    try {
        const transporter = nodemailer.createTransport({
            service: 'gmail',
            auth: {
                user: process.env.EMAIL_USERNAME,
                pass: process.env.EMAIL_PASSWORD,
            },
            logger: true,  // B·∫≠t log chi ti·∫øt
            debug: true,   // B·∫≠t debug
            tls: {
                rejectUnauthorized: false,
            },
        });

        const mailOptions = {
            from: process.env.EMAIL_FROM_ADDRESS, // ƒê·ªãa ch·ªâ g·ª≠i email
            to: to,
            subject: subject,
            html: html,
        };

        const info = await transporter.sendMail(mailOptions);
        console.log("Email ƒë√£ ƒë∆∞·ª£c g·ª≠i:", info.messageId);
    } catch (error) {
        console.error("L·ªói khi g·ª≠i email:", error);
        throw new Error("Kh√¥ng th·ªÉ g·ª≠i email.");
    }
};

export const generateRandomPassword = (length) => {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let password = '';
  for (let i = 0; i < length; i++) {
      password += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return password;
};